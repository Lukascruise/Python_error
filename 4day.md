문제 해결 포트폴리오
이 문서는 색종이 문제를 해결하며 겪었던 과정과 그 속에서 얻은 학습 내용을 기록한 것입니다. 하나의 문제를 다양한 관점에서 접근하고, 더 효율적인 코드를 찾아가는 과정을 통해 프로그래밍 실력이 어떻게 성장했는지 보여주는 것이 목표입니다.

문제명: 색종이 문제
1. 문제 설명
가로, 세로 100인 흰색 도화지에 가로, 세로 10인 검은색 색종이를 여러 장 붙였을 때, 색종이가 붙은 총 면적을 구하는 프로그램입니다. 색종이가 겹치는 부분은 한 번만 넓이에 포함해야 합니다.

2. 해결 과정과 사고의 흐름
이 문제를 해결하기 위해 두 가지 다른 접근 방식을 시도하며 각 방법의 장단점을 파악했습니다.

접근 방식 1: 좌표 리스트 활용
가장 직관적인 방법으로, 각 색종이가 차지하는 모든 좌표를 리스트에 저장하되 중복된 좌표는 제외하는 방식을 사용했습니다.

# 색종이 개수를 입력받습니다.
num_colorpaper = int(input())

# 색종이가 덮은 모든 좌표를 저장할 빈 리스트를 만듭니다.
# 중복을 자동으로 제거하는 set() 자료구조를 사용해도 효율적입니다.
codinate = []

# 입력받은 색종이 개수만큼 반복합니다.
for i in range(num_colorpaper):
    # 각 색종이의 왼쪽 아래 모서리 좌표 (a, b)를 입력받습니다.
    a, b = map(int, input().split())

    # (a, b)를 시작점으로 10x10 크기의 모든 좌표를 생성합니다.
    for x in range(a, a + 10):
        for y in range(b, b + 10):
            # 좌표가 리스트에 이미 존재하지 않는 경우에만 추가합니다.
            # 이 과정을 통해 겹치는 부분을 한 번만 계산합니다.
            if (x, y) not in codinate:
                codinate.append((x, y))

# 리스트에 저장된 좌표의 총 개수를 출력합니다.
# 이 개수가 곧 겹치는 부분을 제외한 총 넓이가 됩니다.
print(len(codinate))

codinate라는 빈 리스트를 만들고, 각 색종이의 10×10 좌표를 반복문을 통해 생성합니다.

if (x,y) not in codinate: 조건문을 사용해, 해당 좌표가 이미 리스트에 없다면 추가합니다.

모든 좌표를 추가한 후, 리스트의 길이(len(codinate))를 출력하여 총 넓이를 구했습니다. 이 방법은 코드가 직관적이지만, 리스트의 크기가 커질수록 in 연산이 느려진다는 단점이 있습니다.

접근 방식 2: 2차원 리스트(도화지) 활용
이전 방식의 비효율성을 개선하기 위해, 도화지 자체를 100x100 크기의 2차원 리스트로 표현하는 방식을 떠올렸습니다.

모든 칸이 0으로 초기화된 total_area라는 2차원 리스트를 만듭니다.

색종이의 위치를 입력받을 때마다 해당 10×10 영역에 있는 칸의 값을 1로 바꿔줍니다.

마지막으로, 2차원 리스트 전체를 순회하며 1이 표시된 칸의 개수를 세어 총 면적을 구했습니다. 이 방법은 중복을 자연스럽게 제거하며, 좌표를 하나하나 비교하는 것보다 훨씬 효율적입니다.

3. 최종 코드
두 번째 접근 방식(2차원 리스트)을 적용하여 완성한 최종 코드는 다음과 같습니다. count() 함수를 사용한 간결한 방법과 중첩 반복문을 사용한 원론적인 방법을 모두 기록하여 문제 해결의 깊이를 보여줍니다.

Python

total_colorpaper = int(input())
total_area = [[0 for _ in range(101)] for _ in range(101)] # 100x100 도화지 (1~100)

for _ in range(total_colorpaper):
    a, b = map(int, input().split())
    for i in range(a, a + 10):
        for j in range(b, b + 10):
            total_area[i][j] = 1

result = 0
for row in total_area:
    result += row.count(1)

print(result)
4. 학습 내용 및 성장 포인트
이 문제를 해결하며 다음과 같은 중요한 점들을 배웠습니다.

다양한 해결책 탐색: 하나의 문제에도 여러 가지 해결 방식이 존재하며, 각 방식에는 장단점이 있다는 것을 깨달았습니다.

자료구조의 선택: 문제의 특성에 따라 어떤 자료구조(리스트, 2차원 리스트)를 사용하는 것이 효율적인지 판단하는 능력을 키웠습니다.

디버깅 능력: 들여쓰기나 변수 초기화 위치와 같은 사소한 오류를 스스로 찾아내고 수정하는 과정을 통해 디버깅 능력을 향상시켰습니다.

코드 리팩토링: count() 함수를 사용하는 것과 같이, 더 간결하고 효율적인 코드를 작성하는 방법을 고민하며 코드 리팩토링의 중요성을 배웠습니다.